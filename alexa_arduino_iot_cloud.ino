#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/bd393c29-d24e-49a2-8780-90b7152eb8c8 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  bool relay_down;
  bool relay_up;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// #define USE_ALEXA

#include "thingProperties.h"
#ifdef USE_ALEXA
#include <Espalexa.h>
#endif

#define ON_ACTIVE_LOW 0
#define OFF_ACTIVE_LOW 1

// vitlo  bravex megaflint Winch 12V WCH2000TL-BX
// based on image search:
// https://www.amazon.com/Bravex-Electric-Reversible-Portable-Power-out/dp/B07B8CMJVJ
// https://www.amazon.com/Megaflint-Reversible-Power-Out-Freewheel-Operations/dp/B078Y3CPKZ
// https://atlanticproducts.com.au/electric-boat-trailer-winch/
// https://www.whitworths.com.au/bada-electric-trailer-winch-2000-wireless-remote-control
// https://www.amazon.com/Portable-Reversible-Power-out-Freewheel-Operations/dp/B094F4VVT9
// https://www.alibaba.com/product-detail/WILLEST-5000-lbs-12v-Electric-Winch_60707914073.html
// USA https://www.harborfreight.com/2000-lb-marine-electric-winch-61237.html

#define RELAY_UP_PIN 16 // D0
#define RELAY_DOWN_PIN 5 // D1

#ifdef USE_ALEXA
Espalexa espalexa;
bool alexaDeviceAdded = false;
#endif

unsigned long currentMillis = 0;    // stores the value of millis() in each iteration of loop()

bool relayDownActive = false;
unsigned long previousRelayDownActivatedMillis = 0; // last time the relay_down was activated
bool relayUpActive = false;
unsigned long previousRelayUpActivatedMillis = 0; // last time the relay_up was activated

#define BLINK_DURATION 100
int blinkActiveTimes = 0;
unsigned long previousBlinkActivedMillis = 0;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 
  Serial.println("setup start");
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // wifi connection event callbacks
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);

  // pins
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(RELAY_UP_PIN, OUTPUT);
  pinMode(RELAY_DOWN_PIN, OUTPUT);
  digitalWrite(RELAY_UP_PIN, OFF_ACTIVE_LOW);
  digitalWrite(RELAY_DOWN_PIN, OFF_ACTIVE_LOW);
  digitalWrite(LED_BUILTIN, OFF_ACTIVE_LOW);

  Serial.println("Setup done");
}

void loop() {
  currentMillis = millis();   // capture the latest value of millis()
  ArduinoCloud.update();
#ifdef USE_ALEXA
  espalexa.loop();
#endif
  checkRelayDown();
  checkRelayUp();
  checkBlink();
}

void checkRelayDown() {
  if (relayDownActive) {
    if (currentMillis > previousRelayDownActivatedMillis &&
        currentMillis - previousRelayDownActivatedMillis >= duration_seconds * 1000) {
      relay_down = false;
      digitalWrite(RELAY_DOWN_PIN, OFF_ACTIVE_LOW);
      relayDownActive = false;
      Serial.println("checkRelayDown.relay_down = false");
    }
  }
}

void checkRelayUp() {
  if (relayUpActive) {
    if (currentMillis > previousRelayUpActivatedMillis &&
        currentMillis - previousRelayUpActivatedMillis >= duration_seconds * 1000) {
      relay_up = false;
      digitalWrite(RELAY_UP_PIN, OFF_ACTIVE_LOW);
      relayUpActive = false;
      Serial.println("checkRelayUp.relay_up = false");
    }
  }
}

// to start blink use
// previousBlinkActivedMillis = millis()
// blinkActiveTimes = 2;
// blinkActiveTimes = 4;
void checkBlink() {
  if (blinkActiveTimes) {
    if (currentMillis > previousBlinkActivedMillis &&
        currentMillis - previousBlinkActivedMillis >= BLINK_DURATION) {
      blinkActiveTimes -= 1;
      digitalWrite(LED_BUILTIN, blinkActiveTimes % 2);
      Serial.print(".");
      previousRelayDownActivatedMillis = currentMillis;
    }
  }
}

void performRelayDown() {
  Serial.print("performRelayDown.relay_down for ");
  Serial.print(duration_seconds);
  Serial.println(" seconds");
  relay_down = true;
  digitalWrite(RELAY_DOWN_PIN, ON_ACTIVE_LOW);
  relayDownActive = true;
  previousRelayDownActivatedMillis = millis();
  // we will shut down in checkRelayDown
}

void performRelayUp() {
  Serial.print("performRelayUp.relay_up for ");
  Serial.print(duration_seconds);
  Serial.println(" seconds");
  relay_up = true;
  digitalWrite(RELAY_UP_PIN, ON_ACTIVE_LOW);
  relayUpActive = true;
  previousRelayUpActivatedMillis = millis();
  // we will shut down in checkRelayUp
}

void onRelayUpChange()  {
  digitalWrite(RELAY_UP_PIN, !relay_up);  // relays is active on low
  blinkActiveTimes = relay_up ? 4 : 2;
  Serial.print("onRelayUpChange relay_up=");
  Serial.println(relay_up);
}

void onRelayDownChange()  {
  digitalWrite(RELAY_DOWN_PIN, !relay_down);
  blinkActiveTimes = relay_up ? 4 : 2;
  Serial.print("onRelayDownChange relay_down=");
  Serial.println(relay_down);
}

void onStartRelayDownChange()  {
  if (startRelayDown) {
    Serial.print("startRelayDown=true ");
    performRelayDown();
  }
}

void onStartRelayUpChange()  {
  if (startRelayUp) {
    Serial.print("startRelayUp=true ");
    performRelayUp();
  }
}

void onDurationSecondsChange()  {
}

void firstDeviceChanged(uint8_t brightness) {
  Serial.print("firstDeviceChanged changed to ");

  if (brightness) {
    blinkActiveTimes = 2;
    Serial.print("ON, brightness ");
    Serial.println(brightness);
    performRelayDown();
  }
  else  {
    blinkActiveTimes = 4;
    Serial.println("OFF");
    performRelayUp();
  }
}

// https://github.com/arduino-libraries/Arduino_ConnectionHandler
void onNetworkConnect() {
  digitalWrite(LED_BUILTIN, ON_ACTIVE_LOW);
  Serial.print(">>>> CONNECTED to network. ");
  if (!alexaDeviceAdded) {
    alexaDeviceAdded = true;
    Serial.println("espalexa.addDevice Light 1");
    espalexa.addDevice("Light 1", firstDeviceChanged);
    espalexa.begin();
  } else {
    Serial.println("Keep using old device");
  }
}

void onNetworkDisconnect() {
  digitalWrite(LED_BUILTIN, OFF_ACTIVE_LOW);

  Serial.println(">>>> DISCONNECTED from network");
}

void onNetworkError() {
  digitalWrite(LED_BUILTIN, OFF_ACTIVE_LOW);

  Serial.println(">>>> ERROR");
}

// https://gist.github.com/ctkjose/09aaed811802ab083f0771a007ac9fcd
// serial_printi("Hello %s\n", "Jose");
// serial_printi("Hello X=%d F=%f\n", 25, 340.36);
void serial_printi(const char *format, ...){
  char ch;
  bool flgInterpolate = false;
  va_list args;
  va_start( args, format );
  for( ; *format ; ++format ){
    ch = *format;
    if(flgInterpolate){
      flgInterpolate = false;
      if((ch=='d') || (ch=='c')){
        Serial.print(va_arg(args, int));
      }else if(ch=='s'){
        Serial.print(va_arg(args, char*));
      }else if(ch=='o'){
        Serial.print(va_arg(args, unsigned int));
      }else if((ch=='f') || (ch=='e') || (ch=='a') || (ch=='g')){
        Serial.print(va_arg(args, double));
      }else{
        Serial.print('%');
        Serial.print(ch);
      }
    }else if(ch=='%'){
      flgInterpolate = true;
    }else{
      Serial.print(ch);
    }
  }

  va_end( args );
}
